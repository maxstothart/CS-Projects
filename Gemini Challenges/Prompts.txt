The Flight Path Validator
A small regional airport needs a program to validate the integrity of its flight data logs.

You are given a text file named flights.log. Each line in the file represents a flight entry, and it is strictly formatted as three comma-separated values: the Flight ID (a string), the Gate Number (an integer), and the Takeoff Time (an integer representing minutes past midnight).

Example flights.log content:

UA221,15,605
DL742,8,1400
BA309,12,710
UA221,15,605
BA309,10,710
QF990,20,1350
Write a C# console application that performs two tasks:

Task 1: Identify Duplicates
Scan the entire log file and identify any flight entry that is an exact duplicate (meaning all three fields: ID, Gate, and Time are identical to another entry).

Task 2: Detect Gate Conflicts
A gate conflict occurs if two different flight entries share the same Gate Number and their Takeoff Times are within 15 minutes of each other (inclusive of the 15-minute window).

Your application must read the flights.log file, process the data, and output the following to the console:

A list of all unique duplicate entries found (print each duplicate entry once).

A list of all flight entries involved in a gate conflict, including the Gate Number and the times of the conflicting flights.
___________________________________________________________________________-

📜 The Energy Grid Load Balancer
A regional power utility needs a tool to monitor substation loads and suggest optimizations to prevent blackouts. You are provided with two data sources.

The Input Data
1. substations.csv Contains the hardware specifications for the power nodes. Format: SubstationID, MaxCapacitykW Example:

S_01, 5000
S_02, 8000
S_03, 3000
2. demand.log Contains the current power draw from various sectors (Industrial, Residential, Commercial). Format: SectorID, SubstationID, CurrentDemandkW Example:

Ind_A1, S_01, 4200
Res_B2, S_01, 900
Com_C1, S_02, 2000
Ind_A2, S_03, 2900
Res_B3, S_02, 1500
The Task
Write a C# application that processes these files and performs the following three technical audits:

1. Identify "Critical Overload"
Find any substation where the sum of its connected CurrentDemandkW exceeds its MaxCapacitykW. Print the Substation ID and the total kilowatts over the limit.

2. Sector Orphan Check
Identify any SectorID in the demand.log that is attempting to draw power from a SubstationID that does not exist in the substations.csv file.

3. The "Smart Rebalance" Suggestion
The utility wants to proactively move sectors to prevent "Near-Critical" substations (defined as usage > 90% of capacity).

For every substation currently over 90% capacity:

Find the single largest Sector (by demand) connected to it.

Check if there is another substation in the grid that is currently below 50% capacity.

If such a substation exists, print a suggestion: "Move Sector [SectorID] from [OverloadedSubstation] to [UnderloadedSubstation]."

Constraints
The application must handle the math using double or decimal for precision.

The output should be a clean report formatted for a technician to read.

Do not assume the files are sorted by ID.
____________________________________________________

📜 The Multi-Source Log Aggregator
A high-frequency trading firm needs a tool to merge and sort log files coming from three different servers. The catch? The logs are messy, timestamps are inconsistent, and you need to process them as if they were a single "stream."

The Input
Create three text files: server_alpha.log, server_beta.log, and server_gamma.log. Each line follows this format: [ISO-8601 Timestamp] | [Priority] | [Message]

Example Data:

2025-12-22T10:00:01 | INFO | Connection established

2025-12-22T09:59:55 | ERROR | Database timeout (Note: This might appear in a different file)

The Task
1. The Unified Streamer
Write a system that reads all three files simultaneously. You must create a single "Merged List" of log objects.

Challenge: You cannot just append one file after the other. The resulting list must be strictly ordered by Timestamp, regardless of which file the entry came from.

2. The "Stateful" Filter
As you process the merged logs, your system must track the "System Health State."

Rule: If the system encounters 3 ERROR messages within any 30-second window across any of the logs, it must inject a custom "CRITICAL ALERT" entry into your final output.

3. The Deduplicator
If two logs have the exact same timestamp and message but come from different servers, merge them into a single entry and add a tag: [Source: Alpha, Beta].

4. The Summary Report
Export the final, sorted, deduplicated, and alert-injected list into a new file: master_audit.log.

At the bottom of the file, generate a summary table:

Total entries per Priority (INFO, WARNING, ERROR, CRITICAL).

The "Peak Error Period" (The 5-minute window with the highest density of logs).

Why this is the "Next Level":
DateTime Handling: You'll need to parse ISO-8601 strings into DateTime objects to compare them accurately.

Complex Sorting: You’ll likely use LINQ’s .OrderBy() or implement IComparable on a LogEntry class.

Time-Window Logic: Tracking the "3 errors in 30 seconds" requires a "Sliding Window" algorithm—this is a classic senior-level interview concept.

How do you want to handle the 30-second window? Would you 

like a fresh set of "noisy" log data to test the time-sensitive alerts?

________________________________________________________________________-

📜 The Automated Cargo Port Controller
A shipping port uses automated cranes to load and unload containers. You need to write a controller that calculates the most efficient sequence of moves for a single crane based on "Stack Logic."

The Setup: The Yard
The yard is represented as a Dictionary or Array of Stacks.

There are 5 lanes (Lanes 1–5).

Each lane can hold a stack of containers.

Containers have a Weight (int) and a Destination (string).

The Task: The "Priority Unload" Algorithm
You are given a ship_manifest.txt containing containers currently on a ship that need to be placed into the yard.

Manifest Format: ContainerID, Weight, Priority (Priority 1 is highest, 10 is lowest)

1. The Stability Rule
When placing a container into a lane, you cannot place a heavier container on top of a lighter one (it would crush it). If a lane's top container is lighter than the one you are holding, that lane is "Blocked."

2. The Efficiency Rule
Containers with Priority 1-3 must be placed in Lanes 1 or 2. All other containers go in Lanes 3-5.

3. The "Digging" Operation
If a container must be placed, but all valid lanes for its priority are "Blocked" (because the top containers are too light):

You must "Dig": Move the blocking container from the top of a lane to a "Temporary Holding Stack."

Place your new container.

Move the temporary container back on top only if the stability rule still allows it. If not, it stays in a "Relocation Queue."

4. The Report
After processing the manifest, your program must output:

The final state of all 5 lanes (which containers are in which stack).

The Relocation Count: How many times a container had to be moved to a temporary spot just to get to another one.

Any "Stranded" containers that couldn't be placed anywhere due to weight limits.

Why this is the "Next Level":
Data Structures: You will likely use Stack<T> for the lanes and Queue<T> for the incoming ship manifest.

Recursive or Iterative Logic: Handling the "Digging" operation requires careful logic to ensure you don't create an infinite loop of moving containers back and forth.

Validation: You'll need to check multiple conditions (Priority, Weight, and Lane Availability) before every single move.

🧪 Sample Data to start with:
Ship Container A: Weight 500, Priority 2

Ship Container B: Weight 800, Priority 1

Ship Container C: Weight 300, Priority 5

The Problem: Container A goes in Lane 1. Container B is higher priority and must go in Lane 1 or 2, but it is heavier than A. You'll have to move A to get B under it, or put B in Lane 2.